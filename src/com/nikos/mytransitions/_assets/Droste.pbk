<languageVersion : 1.0;>

kernel Droste
<   namespace : "com.subblue.filters";
    vendor : "Tom Beddard";
    version : 1;
    description : "The Droste effect.";
>

// Based on the Mathmap version described in the Escher Droste Flickr group:
// http://www.flickr.com/groups/escherdroste/
//
// Original Droste formula by: 
// Ben Reichardt: http://www.flickr.com/photos/breic
// Additional Features and Mathmap 1.2 conversion by:
// Josh Sommers: http://www.flickr.com/photos/joshsommers
// 
// The math behind the transformation:
// http://escherdroste.math.leidenuniv.nl/
// http://www.josleys.com/articles/printgallery.htm
// 
// Examples on using the parameters and further updates to the code at:
// http://www.subblue.com/projects/droste
//
// Quickstart
// 
// These are the steps you should follow for best results:
// 1) Set the size to match the source image
// 2) Adjust the shift so that the spiral is centered on the area you want to repeat
// 3) If the source image is a 24-bit PNG with a transparent centre section 
//    (like a picture frame) then set enableTransparencyInside to 1.
//    If the image has a transparent outside (like a flower cut-out) set enableOutsideTransparency to 1
// 4) Adjust the inner radius in combination with tweaking the shift values until the repeated section
//    aligns nicely.
// 5) Adjust the center parameter to frame the overall image.
//
// Tips
// 
// Periodicity:
//   This sets the number of times the image is repeat on each level of the spiral. For 
//   picture frame type images leave this as 1. For circular images small adjustments 
//   might be needed to get a nice repeating spiral but it is always worth enabling
//   the setAutoPeriodicity setting.
//
// Levels:
//   Increase the startLevel so that the image fills the outer area.
//   Increase the numberOfLevels until the centre of the spiral has filled in.
//
// Strands:
//   This sets the number of arms on the spiral. When set greater than 1 and applied to an image 
//   like a flower that has an outside transparency then strandMirror for seamless tiling.
//
// Poles and other mapping effects:
//   When enablePoles is set then the polarCoordinates can be used.
//   When tilePoles is set then enableHyperDroste setting can be applied and the fractal points
//   setting will then take effect.
//   The untwist option will tile the untwisted annular section effectively unrolling a circular
//   image.



// Constants
#define PI 3.1415926535897932384626433832795
#define I float2(0.0, 1.0)

// Complex math operations
#define complexMult(a,b) float2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x)
#define complexMag(z) float(pow(length(z), 2.0))
#define complexReciprocal(z) float2(z.x / complexMag(z), -z.y / complexMag(z))
#define complexDivision(a,b) complexMult(a, complexReciprocal(b))
#define complexArg(z) float(atan(z.y, z.x))
#define complexLog(z) float2(log(length(z)), complexArg(z))
#define complexExp(z) float2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y))
#define sinh(x) float((exp(x) - exp(-x)) / 2.0)
#define cosh(x) float((exp(x) + exp(-x)) / 2.0)
#define complexSin(z) float2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y))
#define complexCos(z) float2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y))
#define complexTan(z) float2(sin(2.0 * z.x)/(cos(2.0 * z.x) + cosh(2.0 * z.y)), sinh(2.0 * z.y)/(cos(2.0 * z.x) + cosh(2.0 * z.y)))
#define complexSinh(z) float2(sinh(z.x) * cos(z.y), cosh(z.x) * sin(z.y))
#define complexCosh(z) float2(cosh(z.x) * cos(z.y), sinh(z.x) * sin(z.y))
#define complexTanh(z) float2(sinh(2.0 * z.x)/(cosh(2.0 * z.a) + cos(2.0 * z.y)), sin(2.0 * z.y)/(cosh(2.0 * z.x) + cos(2.0 * z.y)))
#define polar(r,a) float2(cos(a) * r, sin(a) * r)
#define power(z,p) float2(polar(pow(length(z), float(p)), float(p) * complexArg(z)))



{
    input image4 src;
    output pixel4 dst;
    
    parameter int2 size
    <
        minValue:int2(100, 100);
        maxValue:int2(4000, 4000);
        defaultValue:int2(600, 600);
        description: "Set to match source image size";
    >;
    
    parameter float innerRadius
    <
        minValue:0.1;
        maxValue:100.0;
        defaultValue:25.0;
        description: "The inner radius of the repeating annular";
    >;
    
    parameter float outerRadius
    <
        minValue:1.0;
        maxValue:100.0;
        defaultValue:100.0;
        description: "The outer radius of the repeating annular";
    >;
    
    parameter float periodicity
    <
        minValue:-6.0;
        maxValue: 6.0;
        defaultValue:1.0;
        description: "The number of image the image is repeated on each level";
    >;
    
    parameter float strands
    <
        minValue:-6.0;
        maxValue: 6.0;
        defaultValue:1.0;
        description: "The number of strands of the spiral";
    >;
    
    parameter int strandMirror
    <
        minValue:0;
        maxValue:1;
        defaultValue:0;
        description: "Activate for smoother repeating when using more than one strand";
    >;
    
    parameter float zoom
    <
        minValue:0.0;
        maxValue:30.0;
        defaultValue:0.0;
        description: "Overall image magnification";
    >;

    parameter float rotate
    <
        minValue:-360.0;
        maxValue: 360.0;
        defaultValue:0.0;
        description: "Overall image rotation";
    >;
    
    parameter float2 center
    <
        minValue:float2(-200.0, -200.0);
        maxValue:float2(200.0, 200.0);
        defaultValue:float2(0.0, 0.0);
        description: "Panning of the image in the output frame";
    >;
    
    parameter float2 centerShift
    <
        minValue:float2(-200.0, -200.0);
        maxValue:float2(200.0, 200.0);
        defaultValue:float2(0.0, 0.0);
        description: "Shift the centre of the spiral";
    >;
    
    parameter int numberOfLevels
    <
        minValue:1;
        maxValue:20;
        defaultValue:9;
        description: "The number of repeating levels of the spiral";
    >;
    
    parameter int startLevel
    <
        minValue:1;
        maxValue:20;
        defaultValue:3;
        description: "The starting spiral level";
    >;
    
    parameter int enableTransparencyInside
    <
        minValue:0;
        maxValue:1;
        defaultValue:0;
        description: "Enable for images with transparent middle areas (such as a picture frame).";
    >;
    
    parameter int enableTransparencyOutside
    <
        minValue:0;
        maxValue:1;
        defaultValue:0;
        description: "Enable for images with transparent areas around the outside.";
    >;
    
    parameter int untwist
    <
        minValue:0;
        maxValue:1;
        defaultValue:0;
        description: "Unroll the circular annular of the image.";
    >;
    
    parameter int setAutoPeriodicity
    <
        minValue:0;
        maxValue:1;
        defaultValue:0;
        description: "Automatically set the ideal periodicity for the current radius settings.";
    >;
    
    parameter float3 polarCoordinates
    <
        minValue: float3(-180, -100, -100);
        maxValue: float3(180, 100, 100);
        defaultValue: float3(90, 0, 0);
        description: "Polar rotation, latitude and longitude";
    >;
    
    parameter int enablePoles
    <
        minValue:0;
        maxValue:1;
        defaultValue:0;
        description: "Show both poles";
    >;
    
    parameter int enableHyperDroste
    <
        minValue:0;
        maxValue:1;
        defaultValue:0;
        description: "Enable hyper droste effect. Applies when enablePoles active.";
    >;

    parameter int tilePoles
    <
        minValue:0;
        maxValue:1;
        defaultValue:0;
        description: "Enable for hyper droste option.";
    >;
    
    parameter int fractalPoints
    <
        minValue:1;
        maxValue:10;
        defaultValue:1;
        description: "Used by hyper droste option.";
    >;
    
    dependent float     r1, r2, p1, p2, w, h, alphaThreshold;
    dependent float2    _shift, _center, _rotate, _zoom, xBounds, yBounds, xyMiddle, minDimension;
    dependent bool      showPoles, hyperDroste, tileBasedOnTransparency, transparentPointsIn, twist;
    
    
    // Initialize parameters
    void evaluateDependents()
    {
        // Set code variables
        r1 = innerRadius / 100.0;
        r2 = outerRadius / 100.0;
        p1 = periodicity;
		if (p1 == 0.0) p1 = 0.001;		// Prevent divide by zero
        p2 = strands;
        transparentPointsIn = enableTransparencyOutside == 0 ? true : false;
        tileBasedOnTransparency = (enableTransparencyInside == 1 || !transparentPointsIn) ? true : false;
        twist = untwist == 0 ? true : false;
        alphaThreshold = 0.01;
        
        _shift = 1.0 + centerShift / 100.0;
        _center = (float2(size) / 2.0) + center * (float2(size) / 2.0) / 100.0;
        w = float(size.x);
        h = float(size.y);
        minDimension = float2(min(w, h) / 2.0);
        
        // Autoset periodicity
        if (setAutoPeriodicity == 1) {
            p1 = p2/2.0 * (1.0 + sqrt(1.0 - pow(log(r2/r1)/PI, 2.0)));
        }
        
        // Set rotation
        _rotate = p1 > 0.0 ? float2(-(PI/180.0) * rotate, 0.0) : float2((PI/180.0) * rotate, 0.0);
        
        // Set zoom
        _zoom = float2((exp(zoom) + innerRadius - 1.0) / 100.0, 0.0);
        
        // Scale viewport pixels to complex plane
        if (twist) {
            xBounds = float2(-r2, r2);
            yBounds = float2(-r2, r2);
        } else {
            xBounds = float2(-log(r2/r1), log(r2/r1));
            yBounds = float2(0.0, 2.1 * PI);
        }
        
        xyMiddle = float2((xBounds.x + xBounds.y) / 2.0, (yBounds.x + yBounds.y) / 2.0);
        float2 xyRange  = float2(xBounds.y - xBounds.x, yBounds.y - yBounds.x);
        xyRange.x = xyRange.y * (w / h);
        xBounds = float2(xyMiddle.x - xyRange.x/2.0, xyMiddle.x + xyRange.x/2.0);
        
        // Polar options
        showPoles = enablePoles == 1 ? true : false;
        hyperDroste = enableHyperDroste == 1 ? true : false;
        
    }
    
    
    void renderPixel(
        in      float2  z,
        inout   float   alphaRemaining,
        inout   int     sign,
        inout   int     iteration,
        inout   pixel4  colorSoFar
        )
    {
        float2 d = minDimension * (z + _shift);
        sign = 0;
        
        if (tileBasedOnTransparency || iteration == 0) {
            dst = sample(src, d);
            colorSoFar += dst * (dst.a * alphaRemaining);
            alphaRemaining *= (1.0 - dst.a);
        }
        
        if (tileBasedOnTransparency) {
            if ( transparentPointsIn && alphaRemaining > alphaThreshold) sign = -1;
            if (!transparentPointsIn && alphaRemaining > alphaThreshold) sign = 1;
        } else {
            if (iteration > 0) colorSoFar = sample(src, d);
            float radius = length(z);
            sign = (radius < r1) ? -1 : (radius > r2 ? 1 : 0);
        }
        iteration += 1;
    }
    
    
    void evaluatePixel()
    {
        float2 s = outCoord();
        float2 z, d, ratio, polar;
        float radius, theta, div;
        int iteration;
        int sign = 0;
        float alphaRemaining = 1.0;
        
        z = float2((xBounds.x + (xBounds.y - xBounds.x) * ((s.x - _center.x) + w / 2.0) / w),
                   (yBounds.x + (yBounds.y - yBounds.x) * ((s.y - _center.y) + h / 2.0) / h));
        
        // Only allow for procedural zooming/scaling in the standard coordinates
        if (twist) {
            z = xyMiddle + complexMult(complexDivision((z - xyMiddle), _zoom), complexExp(complexMult(-I, _rotate)));
        }
        
        // Extra options
        polar = (float2(polarCoordinates.y, polarCoordinates.z) * w / s.x) / 100.0;
        
        if (showPoles) {
            theta = (PI/180.0) * polarCoordinates.x;
            
            div = (1.0 + pow(z.x, 2.0) + pow(z.y, 2.0) + ((1.0 - pow(z.x, 2.0) - pow(z.y, 2.0)) * cos(theta)) - (2.0 * z.x * sin(theta))) / 2.0;
            z.x = z.x * cos(theta) + ((1.0 - pow(z.x, 2.0) - pow(z.y, 2.0)) * sin(theta) / 2.0);
            z = complexDivision(z, float2(div, 0.0));
        } else {
            if (hyperDroste) {
                z = complexSin(z);
            }
            
            if (tilePoles == 1) {
                z = power(z, fractalPoints);
                z = complexTan(complexMult(z, float2(2.0, 0.0)));
            }
        }
        
        z += polar;
        if (twist) {
            z = complexLog(complexDivision(z, float2(r1, 0.0)));
        }
        
        // Start Droste-effect code
        float2 alpha = float2(atan((p2/p1) * (log(r2/r1) / (2.0*PI))), 0.0);
        float2 f = float2(cos(alpha.x), 0.0);
        float2 beta = complexMult(f, complexExp(complexMult(alpha, I)));
        
        // The angle of rotation between adjacent annular levels
        float2 angle = float2(-2.0 * PI * p1, 0.0);
        
        if (p2 > 0.0) angle = -angle;
        if (strandMirror == 1) angle /= strands;
        
        z = complexDivision(complexMult(float2(p1, 0.0), z), beta);
        z = complexMult(float2(r1, 0.0), complexExp(z));
        // End Droste-effect code
        
        
        // Start drawing
        if (tileBasedOnTransparency && startLevel > 0) {
            if (!transparentPointsIn) ratio = complexMult(float2(r2/r1, 0.0), complexExp(complexMult(angle, I)));
            if ( transparentPointsIn) ratio = complexMult(float2(r1/r2, 0.0), complexExp(complexMult(angle,-I)));
            z = complexMult(z, power(ratio, startLevel));
        }
        
        pixel4 colorSoFar = pixel4(0.0, 0.0, 0.0, 0.0);
        iteration = 0;
        renderPixel(z, alphaRemaining, sign, iteration, colorSoFar);
        
        if (sign < 0) ratio = complexMult(float2(r2/r1, 0.0), complexExp(complexMult(angle, I)));
        if (sign > 0) ratio = complexMult(float2(r1/r2, 0.0), complexExp(complexMult(angle, -I)));
        
        iteration = startLevel;
        int maxIteration = numberOfLevels + startLevel - 1;
        
        while (sign != 0 && iteration < maxIteration) {
            z = complexMult(z, ratio);
            renderPixel(z, alphaRemaining, sign, iteration, colorSoFar);
        }
        
        dst = colorSoFar;
        
    }
}
